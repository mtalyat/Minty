====================
	Header:
====================

String to_string(ImageAddressMode const obj);
    ImageAddressMode parse_to_image_address_mode(String const& string);
    Bool parse_try_image_address_mode(String const& string, ImageAddressMode& value);
    template<>
    inline ImageAddressMode parse_to<ImageAddressMode>(String const& string) { return parse_to_image_address_mode(string); }
    template<>
    inline Bool parse_try<ImageAddressMode>(String const& string, ImageAddressMode& value) { return parse_try_image_address_mode(string, value); }

====================
	Source:
====================

using namespace Minty;

String Minty::to_string(ImageAddressMode const obj)
{
    switch (obj)
	{
		case ImageAddressMode::Repeat: return "Repeat";
		case ImageAddressMode::MirroredRepeat: return "MirroredRepeat";
		case ImageAddressMode::ClampToEdge: return "ClampToEdge";
		case ImageAddressMode::ClampToBorder: return "ClampToBorder";
		case ImageAddressMode::MirroredClampToEdge: return "MirroredClampToEdge";

		default: return "";
	}
}

ImageAddressMode Minty::parse_to_image_address_mode(String const& string)
{
	if (string == "Repeat") return ImageAddressMode::Repeat;
	if (string == "MirroredRepeat") return ImageAddressMode::MirroredRepeat;
	if (string == "ClampToEdge") return ImageAddressMode::ClampToEdge;
	if (string == "ClampToBorder") return ImageAddressMode::ClampToBorder;
	if (string == "MirroredClampToEdge") return ImageAddressMode::MirroredClampToEdge;

	return ImageAddressMode();
}

Bool Minty::parse_try_image_address_mode(String const& string, ImageAddressMode& value)
{
	value = parse_to_image_address_mode(string);
	return value != ImageAddressMode();
}

====================
	Test Header:
====================

#pragma once

#include "Test.h"

void test_ImageAddressMode(Test& _test);

====================
	Test Source:
====================

#include "Test_ImageAddressMode.h"
#include "Minty.h"

void test_ImageAddressMode(Test& _test)
{
	CATEGORY(ImageAddressMode)
	{
        std::vector<std::pair<ImageAddressMode, String>> VALUES = {
			{ImageAddressMode::Repeat, "Repeat"},
			{ImageAddressMode::MirroredRepeat, "MirroredRepeat"},
			{ImageAddressMode::ClampToEdge, "ClampToEdge"},
			{ImageAddressMode::ClampToBorder, "ClampToBorder"},
			{ImageAddressMode::MirroredClampToEdge, "MirroredClampToEdge"},
        };
    
        TEST("To String")
        {
            for (auto const& [value, name] : VALUES)
            {
                EXPECT_EQUAL(to_string(value), name);
            }
        }

        TEST("Parse To")
        {
            for (auto const& [value, name] : VALUES)
            {
                EXPECT_EQUAL(parse_to_image_address_mode(name), value);
            }

            EXPECT_EQUAL(parse_to_image_address_mode(""), ImageAddressMode());
        }

        TEST("Parse Try")
        {
            ImageAddressMode result;
            for (auto const& [value, name] : VALUES)
            {
                EXPECT_TRUE(parse_try_image_address_mode(name, result));
                EXPECT_EQUAL(result, value);
            }

            EXPECT_FALSE(parse_try_image_address_mode("", result));
            EXPECT_EQUAL(result, ImageAddressMode());
        }
	}
}

====================
	Header:
====================

String to_string(ImageLayout const obj);
    ImageLayout parse_to_image_layout(String const& string);
    Bool parse_try_image_layout(String const& string, ImageLayout& value);
    template<>
    inline ImageLayout parse_to<ImageLayout>(String const& string) { return parse_to_image_layout(string); }
    template<>
    inline Bool parse_try<ImageLayout>(String const& string, ImageLayout& value) { return parse_try_image_layout(string, value); }

====================
	Source:
====================

using namespace Minty;

String Minty::to_string(ImageLayout const obj)
{
    switch (obj)
	{
		case ImageLayout::General: return "General";
		case ImageLayout::ColorAttachmentOptimal: return "ColorAttachmentOptimal";
		case ImageLayout::DepthStencilAttachmentOptimal: return "DepthStencilAttachmentOptimal";
		case ImageLayout::DepthStencilReadOnlyOptimal: return "DepthStencilReadOnlyOptimal";
		case ImageLayout::ShaderReadOnlyOptimal: return "ShaderReadOnlyOptimal";
		case ImageLayout::TransferSourceOptimal: return "TransferSourceOptimal";
		case ImageLayout::TransferDestinationOptimal: return "TransferDestinationOptimal";
		case ImageLayout::Preinitialized: return "Preinitialized";

		default: return "";
	}
}

ImageLayout Minty::parse_to_image_layout(String const& string)
{
	if (string == "General") return ImageLayout::General;
	if (string == "ColorAttachmentOptimal") return ImageLayout::ColorAttachmentOptimal;
	if (string == "DepthStencilAttachmentOptimal") return ImageLayout::DepthStencilAttachmentOptimal;
	if (string == "DepthStencilReadOnlyOptimal") return ImageLayout::DepthStencilReadOnlyOptimal;
	if (string == "ShaderReadOnlyOptimal") return ImageLayout::ShaderReadOnlyOptimal;
	if (string == "TransferSourceOptimal") return ImageLayout::TransferSourceOptimal;
	if (string == "TransferDestinationOptimal") return ImageLayout::TransferDestinationOptimal;
	if (string == "Preinitialized") return ImageLayout::Preinitialized;

	return ImageLayout();
}

Bool Minty::parse_try_image_layout(String const& string, ImageLayout& value)
{
	value = parse_to_image_layout(string);
	return value != ImageLayout();
}

====================
	Test Header:
====================

#pragma once

#include "Test.h"

void test_ImageLayout(Test& _test);

====================
	Test Source:
====================

#include "Test_ImageLayout.h"
#include "Minty.h"

void test_ImageLayout(Test& _test)
{
	CATEGORY(ImageLayout)
	{
        std::vector<std::pair<ImageLayout, String>> VALUES = {
			{ImageLayout::General, "General"},
			{ImageLayout::ColorAttachmentOptimal, "ColorAttachmentOptimal"},
			{ImageLayout::DepthStencilAttachmentOptimal, "DepthStencilAttachmentOptimal"},
			{ImageLayout::DepthStencilReadOnlyOptimal, "DepthStencilReadOnlyOptimal"},
			{ImageLayout::ShaderReadOnlyOptimal, "ShaderReadOnlyOptimal"},
			{ImageLayout::TransferSourceOptimal, "TransferSourceOptimal"},
			{ImageLayout::TransferDestinationOptimal, "TransferDestinationOptimal"},
			{ImageLayout::Preinitialized, "Preinitialized"},
        };
    
        TEST("To String")
        {
            for (auto const& [value, name] : VALUES)
            {
                EXPECT_EQUAL(to_string(value), name);
            }
        }

        TEST("Parse To")
        {
            for (auto const& [value, name] : VALUES)
            {
                EXPECT_EQUAL(parse_to_image_layout(name), value);
            }

            EXPECT_EQUAL(parse_to_image_layout(""), ImageLayout());
        }

        TEST("Parse Try")
        {
            ImageLayout result;
            for (auto const& [value, name] : VALUES)
            {
                EXPECT_TRUE(parse_try_image_layout(name, result));
                EXPECT_EQUAL(result, value);
            }

            EXPECT_FALSE(parse_try_image_layout("", result));
            EXPECT_EQUAL(result, ImageLayout());
        }
	}
}

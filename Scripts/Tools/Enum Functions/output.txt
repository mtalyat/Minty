====================
	Header:
====================

String to_string(ShaderInputType const obj);
    ShaderInputType parse_to_shader_input_type(String const& string);
    Bool parse_try_shader_input_type(String const& string, ShaderInputType& value);
    template<>
    inline ShaderInputType parse_to<ShaderInputType>(String const& string) { return parse_to_shader_input_type(string); }
    template<>
    inline Bool parse_try<ShaderInputType>(String const& string, ShaderInputType& value) { return parse_try_shader_input_type(string, value); }

====================
	Source:
====================

using namespace Minty;

String Minty::to_string(ShaderInputType const obj)
{
    switch (obj)
	{
		case ShaderInputType::Sample: return "Sample";
		case ShaderInputType::CombinedImageSampler: return "CombinedImageSampler";
		case ShaderInputType::SampledImage: return "SampledImage";
		case ShaderInputType::StorageImage: return "StorageImage";
		case ShaderInputType::UniformTexelBuffer: return "UniformTexelBuffer";
		case ShaderInputType::StorageTexelBuffer: return "StorageTexelBuffer";
		case ShaderInputType::UniformBuffer: return "UniformBuffer";
		case ShaderInputType::StorageBuffer: return "StorageBuffer";
		case ShaderInputType::UniformBufferDynamic: return "UniformBufferDynamic";
		case ShaderInputType::StorageBufferDynamic: return "StorageBufferDynamic";

		default: return "";
	}
}

ShaderInputType Minty::parse_to_shader_input_type(String const& string)
{
	if (string == "Sample") return ShaderInputType::Sample;
	if (string == "CombinedImageSampler") return ShaderInputType::CombinedImageSampler;
	if (string == "SampledImage") return ShaderInputType::SampledImage;
	if (string == "StorageImage") return ShaderInputType::StorageImage;
	if (string == "UniformTexelBuffer") return ShaderInputType::UniformTexelBuffer;
	if (string == "StorageTexelBuffer") return ShaderInputType::StorageTexelBuffer;
	if (string == "UniformBuffer") return ShaderInputType::UniformBuffer;
	if (string == "StorageBuffer") return ShaderInputType::StorageBuffer;
	if (string == "UniformBufferDynamic") return ShaderInputType::UniformBufferDynamic;
	if (string == "StorageBufferDynamic") return ShaderInputType::StorageBufferDynamic;

	return ShaderInputType();
}

Bool Minty::parse_try_shader_input_type(String const& string, ShaderInputType& value)
{
	value = parse_to_shader_input_type(string);
	return value != ShaderInputType();
}

====================
	Test Header:
====================

#pragma once

#include "Test.h"

void test_ShaderInputType(Test& _test);

====================
	Test Source:
====================

#include "Test_ShaderInputType.h"
#include "Minty.h"

void test_ShaderInputType(Test& _test)
{
	CATEGORY(ShaderInputType)
	{
        std::vector<std::pair<ShaderInputType, String>> VALUES = {
			{ShaderInputType::Sample, "Sample"},
			{ShaderInputType::CombinedImageSampler, "CombinedImageSampler"},
			{ShaderInputType::SampledImage, "SampledImage"},
			{ShaderInputType::StorageImage, "StorageImage"},
			{ShaderInputType::UniformTexelBuffer, "UniformTexelBuffer"},
			{ShaderInputType::StorageTexelBuffer, "StorageTexelBuffer"},
			{ShaderInputType::UniformBuffer, "UniformBuffer"},
			{ShaderInputType::StorageBuffer, "StorageBuffer"},
			{ShaderInputType::UniformBufferDynamic, "UniformBufferDynamic"},
			{ShaderInputType::StorageBufferDynamic, "StorageBufferDynamic"},
        };
    
        TEST("To String")
        {
            for (auto const& [value, name] : VALUES)
            {
                EXPECT_EQUAL(to_string(value), name);
            }
        }

        TEST("Parse To")
        {
            for (auto const& [value, name] : VALUES)
            {
                EXPECT_EQUAL(parse_to_shader_input_type(name), value);
            }

            EXPECT_EQUAL(parse_to_shader_input_type(""), ShaderInputType());
        }

        TEST("Parse Try")
        {
            ShaderInputType result;
            for (auto const& [value, name] : VALUES)
            {
                EXPECT_TRUE(parse_try_shader_input_type(name, result));
                EXPECT_EQUAL(result, value);
            }

            EXPECT_FALSE(parse_try_shader_input_type("", result));
            EXPECT_EQUAL(result, ShaderInputType());
        }
	}
}

#pragma once
#include <vector>
#include <string>

/// <summary>
/// Stores the results of a test.
/// </summary>
class Results
{
public:
	enum class MessageType
	{
		Generic,
		Pass,
		Fail
	};

private:
	/// <summary>
	/// List of messages generated by the test.
	/// </summary>
	std::vector<std::string> m_messages;

	/// <summary>
	/// Indices of the test messages that passed.
	/// </summary>
	std::vector<size_t> m_passes;

	/// <summary>
	/// Indices of the test messages that failed.
	/// </summary>
	std::vector<size_t> m_fails;

public:
	Results()
		: m_messages()
		, m_passes()
		, m_fails()
	{
	}

	size_t get_pass_count() const
	{
		return m_passes.size();
	}

	size_t get_fail_count() const
	{
		return m_fails.size();
	}

	std::vector<std::string> const& get_messages() const
	{
		return m_messages;
	}

	std::string const& get_message(size_t const index) const
	{
		return m_messages.at(index);
	}

	std::vector<size_t> const& get_passes() const
	{
		return m_passes;
	}

	std::vector<size_t> const& get_fails() const
	{
		return m_fails;
	}

	void add_message(std::string const& message, MessageType const type)
	{
		switch (type)
		{
		case MessageType::Pass:
			m_passes.push_back(m_messages.size());
			break;
		case MessageType::Fail:
			m_fails.push_back(m_messages.size());
			break;
		}
		m_messages.push_back(message);
	}
};